import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from google.colab import files # Librería para interactuar con el entorno de Colab
import io # Librería necesaria para leer el archivo cargado en memoria

# Configuración para visualizaciones y pandas
sns.set_style("whitegrid")
pd.options.display.max_columns = None
plt.rcParams['figure.figsize'] = [10, 6]

print("=========================================================")
print("  ANÁLISIS DE DATOS: PATRONES DE SUEÑO Y ESTILOS DE VIDA")
print("=========================================================")

# --- 1. Carga Interactiva del Dataset (Método Robusto) ---
try:
    print("\n--- PASO 1: CARGA DEL ARCHIVO (Debe seleccionar 'Sleep_health_and_lifestyle_dataset.csv') ---")
    
    # 1.1. Inicia la carga interactiva (le pedirá seleccionar el archivo)
    uploaded = files.upload()
    
    # 1.2. Lee el archivo cargado directamente en la memoria
    file_name = list(uploaded.keys())[0] # Obtiene el nombre del archivo subido
    df = pd.read_csv(io.BytesIO(uploaded[file_name]))
    
    print(f"\n✅ Archivo '{file_name}' cargado correctamente. Iniciando análisis...")
except Exception as e:
    print(f"❌ ERROR CRÍTICO EN LA CARGA: {e}")
    print("El error persiste. Asegúrese de que el archivo CSV sea válido.")
    exit() 

# --- A partir de aquí, el resto del código es el análisis completo ---

# --- 2. Exploración de Datos y Transformaciones Iniciales ---
print("\n--- 2. Exploración de Datos (Limpieza y Transformaciones) ---")
print(f"Dimensiones Iniciales: {df.shape[0]} filas, {df.shape[1]} columnas")

# 2.1. Tratamiento de Duplicados
num_duplicados = df.duplicated().sum()
if num_duplicados > 0:
    df.drop_duplicates(inplace=True)

# 2.2. Transformaciones
# Separar 'Blood Pressure' y corregir 'BMI Category'
df[['Systolic_BP', 'Diastolic_BP']] = df['Blood Pressure'].str.split('/', expand=True).astype(float)
df.drop('Blood Pressure', axis=1, inplace=True)
df['BMI Category'] = df['BMI Category'].replace('Normal Weight', 'Normal')
df.drop('Person ID', axis=1, inplace=True)
print("Limpieza inicial completada.")

# --- 3. Análisis Univariante y Deducciones ---
print("\n\n--- 3. Análisis Univariante y Deducciones ---")
num_cols = df.select_dtypes(include=np.number).columns.tolist()
cat_cols = df.select_dtypes(include='object').columns.tolist()

# Visualización Categórica
fig_cat, axes_cat = plt.subplots(2, 2, figsize=(18, 12))
axes_cat = axes_cat.flatten()
for i, col in enumerate(cat_cols):
    sns.countplot(y=df[col], ax=axes_cat[i], order=df[col].value_counts().index, palette='viridis')
    axes_cat[i].set_title(f'Conteo de {col}', fontsize=14)
plt.tight_layout()
plt.show() 

# --- 4. Filtrado de Outliers por IQR ---
def remove_outliers_iqr(df, columns):
    df_filtered = df.copy()
    initial_rows = len(df_filtered)
    for col in columns:
        Q1 = df_filtered[col].quantile(0.25)
        Q3 = df_filtered[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        df_filtered = df_filtered[(df_filtered[col] >= lower_bound) & (df_filtered[col] <= upper_bound)]
    final_rows = len(df_filtered)
    print(f"\nFilas iniciales: {initial_rows}. Filas finales: {final_rows}. Outliers eliminados: {initial_rows - final_rows}")
    return df_filtered

numerical_cols_for_iqr = ['Age', 'Sleep Duration', 'Quality of Sleep', 'Physical Activity Level', 
                          'Stress Level', 'Heart Rate', 'Daily Steps', 'Systolic_BP', 'Diastolic_BP']
df_filtered = remove_outliers_iqr(df.copy(), numerical_cols_for_iqr)
df = df_filtered.copy()
print("\n--- Explicación del Filtrado por IQR ---")
print("Se utilizó el filtro IQR para eliminar *outliers* extremos y aumentar la robustez de los datos para el modelado.")

# --- 5 & 6. Creación de Variable Objetivo y Eliminación de 'Stress Level' ---
df['Nivel_Estres_Binario'] = df['Stress Level'].apply(
    lambda x: 'ESTRESADO' if x >= 7 else 'ESTRES MODERADO'
)
df.drop('Stress Level', axis=1, inplace=True)

# --- 7. Análisis Bivariante ---
print("\n\n--- 7. Análisis Bivariante ---")
target_col = 'Nivel_Estres_Binario'

# Visualización Numérica vs. Target (Boxplots)
num_cols_biv = [col for col in num_cols if col != 'Stress Level']
fig_biv_num, axes_biv_num = plt.subplots(3, 3, figsize=(18, 18))
axes_biv_num = axes_biv_num.flatten()
for i, col in enumerate(num_cols_biv):
    sns.boxplot(x=target_col, y=col, data=df, ax=axes_biv_num[i], palette='viridis')
    axes_biv_num[i].set_title(f'{col} vs. {target_col}', fontsize=14)
plt.tight_layout()
plt.show() 

# --- 8. Matriz de Correlación y Eliminación de Variables ---
df['Target_Encoded'] = df[target_col].apply(lambda x: 1 if x == 'ESTRESADO' else 0)
correlation_df = df[num_cols_biv + ['Target_Encoded']].copy()
corr_matrix = correlation_df.corr()

plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Matriz de Correlación de Variables Numéricas y Target', fontsize=16)
plt.show() 

df.drop(['Sleep Duration', 'Diastolic_BP', 'Target_Encoded'], axis=1, inplace=True)
print("\n**Variables Eliminadas por Colinealidad/Redundancia:** Sleep Duration, Diastolic_BP.")


# --- 9. División del Dataset (Train/Test 80/20 Estratificado) y Guardado ---
df_final = pd.get_dummies(df, columns=['Gender', 'Occupation', 'BMI Category', 'Sleep Disorder'], drop_first=True)
X = df_final.drop(target_col, axis=1)
y = df_final[target_col]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

df_train = pd.concat([X_train, y_train], axis=1)
df_test = pd.concat([X_test, y_test], axis=1)

df_train.to_csv('train.csv', index=False)
df_test.to_csv('test.csv', index=False)

print("\n\n--- 9. Comprobación de Estratificación y Guardado ---")
train_proportion = y_train.value_counts(normalize=True) * 100
test_proportion = y_test.value_counts(normalize=True) * 100
print("Archivos 'train.csv' y 'test.csv' generados.")

# --- 10. DESCARGAR ARCHIVOS GENERADOS ---
try:
    print("\n=========================================================")
    print("  DESCARGANDO ARCHIVOS A SU COMPUTADORA...")
    print("=========================================================")
    files.download('train.csv')
    files.download('test.csv')
except Exception as e:
    pass # No hacemos nada si falla la descarga automática
